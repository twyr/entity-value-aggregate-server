<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<title>JSDoc: Source: ingress_surfaces/rest_api/index.js</title>
		<script src="scripts/prettify/prettify.js"> </script>
		<script src="scripts/prettify/lang-css.js"> </script>
		<!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
		<link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
		<link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
	</head>

	<body>
		<div id="main">
			<h1 class="page-title">Source: ingress_surfaces/rest_api/index.js</h1>
			<section>
				<article>
					<pre class="prettyprint source linenums"><code>/**
 * Imports for this file
 * @ignore
 */
import http from 'node:http';
import networkInterfaces from 'node:os';

import convertHrtime from 'convert-hrtime';
// import helmet from 'koa-helmet';

import { v4 as uuidv4 } from 'uuid';

import { EVASBaseIngressSurface } from '@twyr/framework-classes';
import { EVASBaseFactory } from '@twyr/framework-classes';
import { errorSerializer } from '@twyr/error-serializer';

/**
 * Magic Number constants
 * @ignore
 */
// const DEFAULT_MAX_EVENT_LOOP_DELAY = 10_000; // 10 seconds
const DEFAULT_MAX_PAYLOAD_SIZE = '10mb';
const DEFAULT_POWERED_BY = 'Twyr';

// const DEFAULT_RATE_LIMIT_INTERVAL = 5 * 60 * 1000; // 5 minutes
// const DEFAULT_RATE_LIMIT_MAX_REQUESTS = 30;

const DEFAULT_SESSION_DOMAIN = '127.0.0.1';
const DEFAULT_SESSION_ENCRYPTION_KEY = 'Th1s!sTheTwyrEntityAggregateServer';
const DEFAULT_SESSION_KEY = 'twyr.entity.aggregate.server';
const DEFAULT_SESSION_MAX_AGE = 86_400_000;
const DEFAULT_SERVER_PORT = 9090;

const MAX_API_VERSION = 1;

/**
 * @class RestApi
 * @extends EVASBaseIngressSurface
 *
 * @param {string} [location] - __dirname for this file in CJS, basically
 * @param {object} [iocContainer] - IoC module providing DI repositories
 * @param {object} [configuration] - requested repository configuration
 *
 * @classdesc The RestApi Repository Class.
 *
 */
class RestApi extends EVASBaseIngressSurface {
	// #region Constructor
	constructor(location, iocContainer, configuration) {
		super(location, iocContainer, configuration);
	}
	// #endregion

	// #region Lifecycle Methods
	/**
	 * @memberof RestApi
	 * @async
	 * @instance
	 * @override
	 * @function
	 * @name load
	 *
	 * @returns {null} - Nothing
	 *
	 * @description
	 * To be overridden by artifact implementations - for implementing custom
	 * start logic
	 *
	 */
	async load() {
		await super.load?.();

		const cache = await this?.iocContainer?.resolve?.('Cache');
		// const logger = await this?.iocContainer?.resolve?.('Logger');

		/**
		 * Step 1: Setup the configuration
		 * @ignore
		 */
		let configuration = this.configuration;
		if (!configuration) {
			const configRepository =
				await this?.iocContainer?.resolve?.('Configuration');

			configuration = await configRepository?.getConfig?.(this?.name);
		}

		const sessionConfig = {
			keys: configuration?.['SESSION_KEYS'] ?? [
				DEFAULT_SESSION_ENCRYPTION_KEY
			],
			autoCommit: true,
			domain: configuration?.['SESSION_DOMAIN'] ?? DEFAULT_SESSION_DOMAIN,
			key: configuration?.['SESSION_KEY'] ?? DEFAULT_SESSION_KEY,
			maxAge:
				configuration?.['SESSION_MAX_AGE'] ?? DEFAULT_SESSION_MAX_AGE,
			overwrite: true,
			httpOnly: true,
			signed: true,
			rolling: true,
			renew: true
		};
		sessionConfig.genid = function () {
			return `${
				configuration?.['SESSION_KEY'] ?? DEFAULT_SESSION_KEY
			}!${uuidv4()}`;
		};

		/**
		 * Step 2: Setup Koa Application.
		 * @ignore
		 */

		// Step 2.1: Instantiate Koa
		let Koa = await import('koa');
		Koa = Koa?.['default'];

		this.#koaApp = new Koa();
		this.#koaApp?.on?.('error', this.#handleKoaAppError.bind(this));

		this.#koaApp.keys = sessionConfig?.keys;
		this.#koaApp.proxy = global.serverEnvironment === 'production';

		// Step 2.2: The Global Error Handler
		this.#koaApp?.use?.(this.#errorLog?.bind?.(this));

		// Step 2.3: Assign each request an id to enable
		// distributed tracing...
		let requestId = await import('koa-requestid');
		requestId = requestId?.['default'];
		this.#koaApp?.use?.(
			requestId({
				expose: 'X-Request-Id',
				header: 'X-Request-Id',
				query: 'requestId'
			})
		);

		// Step 2.4: Hide the powered-by header to
		// prevent external entities from easily
		// guessing the stack
		this.#koaApp?.use?.(async (ctxt, next) => {
			ctxt?.request?.socket?.setNoDelay?.(true);

			ctxt.headers['x-request-id'] = ctxt?.state?.id;
			ctxt?.set?.(
				'x-powered-by',
				configuration?.['POWERED_BY'] ?? DEFAULT_POWERED_BY
			);

			await next();
		});

		// Step 2.6: Add in the device identifier
		let device = await import('device');
		device = device?.['default'];

		this.#koaApp?.use?.(async (ctxt, next) => {
			ctxt.state.device = device?.(ctxt?.headers?.['user-agent'] ?? '');
			await next();
		});

		// Step 2.7: Sessions
		let koaSessionRedisStore = await import('koa-redis');
		koaSessionRedisStore = koaSessionRedisStore?.['default'];

		sessionConfig.store = koaSessionRedisStore?.({
			client: cache,
			duplicate: false
		});

		let koaSession = await import('koa-session');
		koaSession = koaSession?.['default']?.(sessionConfig, this.#koaApp);
		koaSession?.on?.(
			'session:missed',
			this.#handleKoaSessionEvents?.bind?.(this)
		);

		koaSession?.on?.(
			'session:invalid',
			this.#handleKoaSessionEvents?.bind?.(this)
		);

		koaSession?.on?.(
			'session:expired',
			this.#handleKoaSessionEvents?.bind?.(this)
		);

		this.#koaApp.use?.(koaSession);

		// Step 2.8: Passport based authentication...
		const authRepository = await this?.iocContainer?.resolve?.('Auth');

		this.#koaApp?.use?.(authRepository?.initialize?.());
		this.#koaApp?.use?.(authRepository?.session?.());

		// Step 2.9: The body parsers...
		const bodyParserConfig = {
			jsonLimit:
				configuration?.['MAX_PAYLOAD_SIZE'] ?? DEFAULT_MAX_PAYLOAD_SIZE,
			textLimit:
				configuration?.['MAX_PAYLOAD_SIZE'] ?? DEFAULT_MAX_PAYLOAD_SIZE,
			xmlLimit:
				configuration?.['MAX_PAYLOAD_SIZE'] ?? DEFAULT_MAX_PAYLOAD_SIZE,
			enableTypes: ['json', 'text', 'xml'],
			extendTypes: {
				json: ['application/x-javascript', 'application/vnd.api+json']
			},
			onError: this.#handleKoaBodyParserError?.bind?.(this)
		};

		let koaBodyParser = await import('koa-bodyparser');
		koaBodyParser = koaBodyParser?.['default'];

		this.#koaApp?.use?.(koaBodyParser(bodyParserConfig));

		// Step 2.10: The audit log hook...
		this.#koaApp?.use?.(this.#auditLog?.bind?.(this));

		// Finally, add in the router...
		let Router = await import('@koa/router');
		Router = Router?.['default'];

		this.#router = new Router({
			prefix: `/api/v${configuration?.['MAX_API_VERSION'] ?? MAX_API_VERSION}`
		});

		this.#koaApp?.use?.(this.#router.routes());
		this.#koaApp?.use?.(this.#router.allowedMethods());
	}

	/**
	 * @memberof RestApi
	 * @async
	 * @instance
	 * @override
	 * @function
	 * @name unload
	 *
	 * @returns {null} - Nothing
	 *
	 * @description
	 * To be overridden by artifact implementations - for implementing custom
	 * stop logic
	 *
	 */
	async unload() {
		await super.unload?.();

		this.#router = undefined;
		this.#koaApp = undefined;
	}
	// #endregion

	// #region Interface API
	/**
	 * @memberof RestApi
	 * @async
	 * @instance
	 * @override
	 * @function
	 * @name start
	 *
	 * @returns {null} - Nothing
	 *
	 * @description
	 * Starts listening on the configured port.
	 */
	async start() {
		if (this.#protocolServer) return;

		const networkList = networkInterfaces?.networkInterfaces?.();

		let configuration = this.configuration;
		if (!configuration) {
			const configRepository =
				await this?.iocContainer?.resolve?.('Configuration');

			configuration = await configRepository?.getConfig?.(this?.name);
		}

		// Step 1: Create the Server
		this.#protocolServer = http?.createServer?.(this.#koaApp?.callback?.());

		// Step 2: Start listening to events
		this.#protocolServer?.on?.(
			'connection',
			this.#serverConnection?.bind?.(this)
		);

		this.#protocolServer?.on?.(
			'error',
			this.#handleProtocolServerError?.bind?.(this)
		);

		// Step 3: Listen on configured port...
		const listenPort = Number?.(
			configuration?.['SERVER_PORT'] ?? DEFAULT_SERVER_PORT
		);

		return new Promise((resolve, reject) => {
			this.#protocolServer?.listen?.(listenPort, () => {
				try {
					if (global.serverEnvironment === 'production') {
						resolve?.();
						return;
					}

					console?.info?.(
						`\n${this?.name}::start: ${JSON?.stringify?.(
							this.#router?.stack
								?.map?.((route) => {
									const routeMethodPaths = route?.methods
										?.map((method) => {
											if (method === 'HEAD') return;
											return `${method} ${route?.path}`;
										})
										?.filter((routeMethodPath) => {
											return !!routeMethodPath;
										});

									return routeMethodPaths?.length > 1
										? routeMethodPaths
										: routeMethodPaths?.shift?.();
								})
								?.filter((route) => {
									return !!route;
								}),
							undefined,
							'\t'
						)}`
					);

					const forPrint = [];
					Object.keys(networkList).forEach((networkName) => {
						const networkInterfaceAddresses =
							// eslint-disable-next-line security/detect-object-injection
							networkList?.[networkName];

						for (const address of networkInterfaceAddresses)
							forPrint.push({
								Interface: networkName,
								Protocol: address.family,
								Address: address.address,
								Port: listenPort
							});
					});

					console?.table?.(forPrint);
					resolve?.();
				} catch (error) {
					reject?.(error);
				}
			});
		});
	}

	/**
	 * @memberof RestApi
	 * @async
	 * @instance
	 * @override
	 * @function
	 * @name stop
	 *
	 * @returns {null} - Nothing
	 *
	 * @description
	 * Stops listening on the configured port.
	 */
	async stop() {
		if (!this.#protocolServer) return;

		this.#koaApp.off('error', this.#handleKoaAppError.bind(this));

		this.#protocolServer.off(
			'error',
			this.#handleProtocolServerError.bind(this)
		);

		this.#protocolServer.off(
			'connection',
			this.#serverConnection.bind(this)
		);

		this.#protocolServer?.closeAllConnections?.();
		this.#protocolServer?.close?.();

		this.#router.stack.length = 0;
		this.#protocolServer = undefined;
	}
	// #endregion

	// #region Getters / Setters
	get interface() {
		return {
			router: this.#router,

			start: this?.start?.bind?.(this),
			stop: this?.stop?.bind?.(this)
		};
	}
	// #endregion

	// #region Private Methods
	async #errorLog(ctxt, next) {
		try {
			await next();
		} catch (error) {
			ctxt.type = 'application/json; charset=utf-8';
			ctxt.status = error?.status ?? 422;
			ctxt.body = error?.message;
		}
	}

	async #auditLog(ctxt, next) {
		let safeJsonStringify = await import('safe-json-stringify');
		safeJsonStringify = safeJsonStringify?.['default'];

		// Step 1: Define the audit log data structure, and populate
		// the basics
		const logMessageMeta = {
			id: ctxt?.state?.id,

			start_time: undefined,
			end_time: undefined,
			duration_in_ms: 0,

			user: {
				id: ctxt?.state?.user?.id,
				name: `${ctxt?.state?.user?.['first_name']} ${ctxt?.state?.user?.['last_name']}`,
				role: ctxt?.session?.passport?.user?.['role'] ?? '???'
			},

			'request-meta': {
				method: ctxt?.request?.method,
				url: ctxt?.request?.url,
				ip: ctxt?.request?.ip,
				ips: JSON?.parse?.(
					safeJsonStringify?.(ctxt?.request?.ips ?? [])
				)
			},

			'response-meta': {},

			data: {
				query: JSON?.parse?.(safeJsonStringify?.(ctxt?.query || {})),
				params: JSON?.parse?.(safeJsonStringify?.(ctxt?.params || {})),
				body: JSON?.parse?.(
					safeJsonStringify?.(ctxt?.request?.body || {})
				),
				payload: undefined
			},

			error: undefined
		};

		// Step 2: Now, execute the request, and log the time taken
		const startTime = process?.hrtime?.bigint?.();
		logMessageMeta['start_time'] = new Date()?.valueOf?.();
		try {
			await next?.();
		} catch (error) {
			logMessageMeta['error'] = error;
		}
		logMessageMeta['end_time'] = new Date()?.valueOf?.();
		const endTime = process?.hrtime?.bigint?.();

		logMessageMeta['duration_in_ms'] = convertHrtime?.(
			endTime - startTime
		)?.milliseconds;

		// Step 3: Fill in the user details, if needed...
		// This is here because, in case of the "login" call, the user
		// is populated only after the login has been successfully executed
		if (!logMessageMeta?.user?.id) {
			logMessageMeta['user'] = {
				id: ctxt?.state?.user?.['id'] ?? '???',
				name: `${ctxt?.state?.user?.['first_name'] ?? '???'} ${
					ctxt?.state?.user?.['last_name'] ?? '???'
				}`,
				role: ctxt?.session?.passport?.user?.['role'] ?? '???'
			};
		}

		// Step 4: Fill in the request header details
		// We do this here, instead of earlier, to ensure that any
		// modifications to the headers by downstream middlewares
		// are also captured - for example, the "userRole" header
		const requestHeaders = {};
		for (const requestHeader in ctxt?.request?.headers ?? {}) {
			// eslint-disable-next-line security/detect-object-injection
			requestHeaders[requestHeader] = JSON?.parse?.(
				// eslint-disable-next-line security/detect-object-injection
				safeJsonStringify?.(ctxt?.request?.headers?.[requestHeader])
			);
		}

		logMessageMeta['request-meta']['headers'] = requestHeaders;

		// Step 5: Fill in the response headers / data / error details
		logMessageMeta['response-meta']['headers'] = JSON?.parse?.(
			safeJsonStringify?.(ctxt?.response?.headers)
		);

		const statusCodes = http?.['STATUS_CODES'];
		logMessageMeta['response-meta']['status'] = {
			code: logMessageMeta?.error?.status ?? ctxt?.status,
			message:
				logMessageMeta?.error?.message ?? statusCodes?.[ctxt?.status],
			responseMessage:
				((logMessageMeta?.error?.message ?? '')?.startsWith?.(
					'ApiMatcher'
				)
					? logMessageMeta?.error?.cause?.message
					: logMessageMeta?.error?.message) ??
				statusCodes?.[ctxt?.status]
		};

		logMessageMeta['data']['payload'] = Buffer?.isBuffer?.(ctxt?.body)
			? 'BUFFER'
			: JSON?.parse?.(safeJsonStringify?.(ctxt?.body || {}));

		logMessageMeta['error'] ??= ctxt?.status >= 400;

		let throwableError;
		if (logMessageMeta?.['error'] instanceof Error) {
			throwableError = logMessageMeta?.['error'];
			logMessageMeta['error'] = errorSerializer?.(
				logMessageMeta?.['error']
			);
		}

		// Finally, publish the audit log and throw error if any
		const auditRepository = await this?.iocContainer?.resolve?.('Audit');
		auditRepository?.publish?.(logMessageMeta);

		if (!throwableError) return;

		if (throwableError?.message?.startsWith?.('ApiMatcher'))
			throw throwableError?.cause ?? throwableError;

		throw throwableError;
	}

	async #serverConnection(socket) {
		const logger = await this?.iocContainer?.resolve?.('Logger');
		logger?.debug?.(`Server Connections: ${socket?._server?._connections}`);
	}

	async #handleProtocolServerError() {
		let safeJsonStringify = await import('safe-json-stringify');
		safeJsonStringify = safeJsonStringify?.['default'];

		const logger = await this?.iocContainer?.resolve?.('Logger');
		logger?.error?.(
			`Server Error: ${safeJsonStringify?.(arguments, undefined, '\t')}`
		);
	}

	async #handleKoaAppError() {
		let safeJsonStringify = await import('safe-json-stringify');
		safeJsonStringify = safeJsonStringify?.['default'];

		const logger = await this?.iocContainer?.resolve?.('Logger');
		logger?.error?.(
			`Koa App Error: ${safeJsonStringify?.(arguments, undefined, '\t')}`
		);
	}

	async #handleKoaSessionEvents() {
		let safeJsonStringify = await import('safe-json-stringify');
		safeJsonStringify = safeJsonStringify?.['default'];

		const logger = await this?.iocContainer?.resolve?.('Logger');
		logger?.info?.(
			`Koa Session Event: ${safeJsonStringify?.(
				arguments,
				undefined,
				'\t'
			)}`
		);
	}

	async #handleKoaBodyParserError() {
		let safeJsonStringify = await import('safe-json-stringify');
		safeJsonStringify = safeJsonStringify?.['default'];

		const logger = await this?.iocContainer?.resolve?.('Logger');
		logger?.error?.(
			`Koa Body Parser Error: ${safeJsonStringify?.(
				arguments,
				undefined,
				'\t'
			)}`
		);
	}
	// #endregion

	// #region Private Fields
	#router = undefined;

	#koaApp = undefined;
	#protocolServer = undefined;
	// #endregion
}

/**
 * @class IngressSurfaceFactory
 * @extends EVASBaseFactory
 *
 * @classdesc The RestApi Ingress Surface Class Factory.
 */
export default class IngressSurfaceFactory extends EVASBaseFactory {
	// #region Constructor
	// eslint-disable-next-line jsdoc/require-jsdoc
	constructor() {
		super();
	}
	// #endregion

	// #region Lifecycle API
	/**
	 * @memberof IngressSurfaceFactory
	 * @async
	 * @static
	 * @override
	 * @function
	 * @name createInstance
	 *
	 * @param {object} [configuration] - requested repository configuration
	 * @param {object} [iocContainer] - IoC Container providing DI Repositories
	 *
	 * @returns {RestApi} - The RestApi repository instance.
	 *
	 */
	static async createInstances(configuration, iocContainer) {
		if (!IngressSurfaceFactory.#restApiInstance) {
			const restApiInstance = new RestApi(
				IngressSurfaceFactory['$disk_unc'],
				iocContainer,
				configuration
			);

			await restApiInstance?.load?.();
			IngressSurfaceFactory.#restApiInstance = restApiInstance;
		}

		return IngressSurfaceFactory.#restApiInstance?.interface;
	}

	/**
	 * @memberof IngressSurfaceFactory
	 * @async
	 * @static
	 * @override
	 * @function
	 * @name destroyInstances
	 *
	 * @param {object} [configuration] - requested repository configuration
	 *
	 * @returns {undefined} - Nothing.
	 *
	 * @description Clears the cached {RestApi} instances
	 */
	// eslint-disable-next-line no-unused-vars
	static async destroyInstances(configuration = 'server') {
		if (!IngressSurfaceFactory.#restApiInstance) return;

		await IngressSurfaceFactory.#restApiInstance?.unload?.();
		IngressSurfaceFactory.#restApiInstance = undefined;

		return;
	}
	// #endregion

	// #region Getters
	/**
	 * @memberof IngressSurfaceFactory
	 * @async
	 * @static
	 * @override
	 * @function
	 * @name IngressSurfaceName
	 *
	 * @returns {string} - Name of this repository.
	 *
	 * @description
	 * Returns the name of this repository - RestApi
	 */
	static get IngressSurfaceName() {
		return 'RestApi';
	}
	// #endregion

	// #region Private Static Members
	static #restApiInstance = undefined;
	// #endregion
}
</code></pre>
				</article>
			</section>
		</div>
		<nav>
			<h2><a href="index.html">Home</a></h2>
			<h3>Classes</h3>
			<ul>
				<li><a href="ApplicationServer.html">ApplicationServer</a></li>
				<li><a href="ApplicationServerFactory.html">ApplicationServerFactory</a></li>
				<li><a href="Audit.html">Audit</a></li>
				<li><a href="Auth.html">Auth</a></li>
				<li><a href="Basics.html">Basics</a></li>
				<li><a href="BoundedContextFactory.html">BoundedContextFactory</a></li>
				<li><a href="Cache.html">Cache</a></li>
				<li><a href="Configuration.html">Configuration</a></li>
				<li><a href="Contact.html">Contact</a></li>
				<li><a href="Contacts.html">Contacts</a></li>
				<li><a href="DomainFactory.html">DomainFactory</a></li>
				<li><a href="EventHandlerFactory.html">EventHandlerFactory</a></li>
				<li><a href="IngressSurfaceFactory.html">IngressSurfaceFactory</a></li>
				<li><a href="Locale.html">Locale</a></li>
				<li><a href="Locales.html">Locales</a></li>
				<li><a href="Logger.html">Logger</a></li>
				<li><a href="Main.html">Main</a></li>
				<li><a href="Masterdata.html">Masterdata</a></li>
				<li><a href="MiddlewareFactory.html">MiddlewareFactory</a></li>
				<li><a href="ModelFactory.html">ModelFactory</a></li>
				<li><a href="MongoDB.html">MongoDB</a></li>
				<li><a href="Notification.html">Notification</a></li>
				<li><a href="Profile.html">Profile</a></li>
				<li><a href="Renderer.html">Renderer</a></li>
				<li><a href="RepositoryFactory.html">RepositoryFactory</a></li>
				<li><a href="RestApi.html">RestApi</a></li>
				<li><a href="SQLDatabase.html">SQLDatabase</a></li>
				<li><a href="ServerUserBaseMiddleware.html">ServerUserBaseMiddleware</a></li>
				<li><a href="ServerUsers.html">ServerUsers</a></li>
				<li><a href="Session.html">Session</a></li>
				<li><a href="SessionManager.html">SessionManager</a></li>
				<li><a href="SurfaceFactory.html">SurfaceFactory</a></li>
			</ul>
			<h3>Global</h3>
			<ul>
				<li><a href="global.html#localStrategy">localStrategy</a></li>
				<li><a href="global.html#serializeDeserialize">serializeDeserialize</a></li>
				<li><a href="global.html#userSessionCache">userSessionCache</a></li>
			</ul>
		</nav>
		<br class="clear">
		<footer>
			Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a>
		</footer>
		<script>
			prettyPrint();

		</script>
		<script src="scripts/linenumber.js"> </script>
	</body>

</html>
